{"ast":null,"code":"/**\r\n * URI.js\r\n *\r\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\r\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\r\n * @see http://github.com/garycourt/uri-js\r\n */\n\n/**\r\n * Copyright 2011 Gary Court. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification, are\r\n * permitted provided that the following conditions are met:\r\n *\r\n *    1. Redistributions of source code must retain the above copyright notice, this list of\r\n *       conditions and the following disclaimer.\r\n *\r\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n *       of conditions and the following disclaimer in the documentation and/or other materials\r\n *       provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * The views and conclusions contained in the software and documentation are those of the\r\n * authors and should not be interpreted as representing official policies, either expressed\r\n * or implied, of Gary Court.\r\n */\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf } from \"./util\";\nexport const SCHEMES = {};\nexport function pctEncChar(chr) {\n  const c = chr.charCodeAt(0);\n  let e;\n  if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n  return e;\n}\nexport function pctDecChars(str) {\n  let newStr = \"\";\n  let i = 0;\n  const il = str.length;\n\n  while (i < il) {\n    const c = parseInt(str.substr(i + 1, 2), 16);\n\n    if (c < 128) {\n      newStr += String.fromCharCode(c);\n      i += 3;\n    } else if (c >= 194 && c < 224) {\n      if (il - i >= 6) {\n        const c2 = parseInt(str.substr(i + 4, 2), 16);\n        newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n      } else {\n        newStr += str.substr(i, 6);\n      }\n\n      i += 6;\n    } else if (c >= 224) {\n      if (il - i >= 9) {\n        const c2 = parseInt(str.substr(i + 4, 2), 16);\n        const c3 = parseInt(str.substr(i + 7, 2), 16);\n        newStr += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n      } else {\n        newStr += str.substr(i, 9);\n      }\n\n      i += 9;\n    } else {\n      newStr += str.substr(i, 3);\n      i += 3;\n    }\n  }\n\n  return newStr;\n}\n\nfunction _normalizeComponentEncoding(components, protocol) {\n  function decodeUnreserved(str) {\n    const decStr = pctDecChars(str);\n    return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n  }\n\n  if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n  if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  return components;\n}\n\n;\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[\\dA-F:.]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nexport function parse(uriString, options = {}) {\n  const components = {};\n  const protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n  if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n  const matches = uriString.match(URI_PARSE);\n\n  if (matches) {\n    if (NO_MATCH_IS_UNDEFINED) {\n      //store each component\n      components.scheme = matches[1];\n      components.userinfo = matches[3];\n      components.host = matches[4];\n      components.port = parseInt(matches[5], 10);\n      components.path = matches[6] || \"\";\n      components.query = matches[7];\n      components.fragment = matches[8]; //fix port number\n\n      if (isNaN(components.port)) {\n        components.port = matches[5];\n      }\n    } else {\n      //store each component\n      components.scheme = matches[1] || undefined;\n      components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n      components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n      components.port = parseInt(matches[5], 10);\n      components.path = matches[6] || \"\";\n      components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n      components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined; //fix port number\n\n      if (isNaN(components.port)) {\n        components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n      }\n    } //strip brackets from IPv6 hosts\n\n\n    if (components.host) {\n      components.host = components.host.replace(protocol.IPV6ADDRESS, \"$1\");\n    } //determine reference type\n\n\n    if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n      components.reference = \"same-document\";\n    } else if (components.scheme === undefined) {\n      components.reference = \"relative\";\n    } else if (components.fragment === undefined) {\n      components.reference = \"absolute\";\n    } else {\n      components.reference = \"uri\";\n    } //check for reference errors\n\n\n    if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n      components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n    } //find scheme handler\n\n\n    const schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()]; //check if scheme can't handle IRIs\n\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      //if host component is a domain name\n      if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n        //convert Unicode IDN -> ASCII IDN\n        try {\n          components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n        } catch (e) {\n          components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n        }\n      } //convert IRI -> URI\n\n\n      _normalizeComponentEncoding(components, URI_PROTOCOL);\n    } else {\n      //normalize encodings\n      _normalizeComponentEncoding(components, protocol);\n    } //perform scheme specific parsing\n\n\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(components, options);\n    }\n  } else {\n    components.error = components.error || \"URI can not be parsed.\";\n  }\n\n  return components;\n}\n;\n\nfunction _recomposeAuthority(components, options) {\n  const protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n  const uriTokens = [];\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo);\n    uriTokens.push(\"@\");\n  }\n\n  if (components.host !== undefined) {\n    //ensure IPv6 addresses are bracketed\n    uriTokens.push(String(components.host).replace(protocol.IPV6ADDRESS, \"[$1]\"));\n  }\n\n  if (typeof components.port === \"number\") {\n    uriTokens.push(\":\");\n    uriTokens.push(components.port.toString(10));\n  }\n\n  return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\n;\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nexport function removeDotSegments(input) {\n  const output = [];\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, \"\");\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, \"/\");\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, \"/\");\n      output.pop();\n    } else if (input === \".\" || input === \"..\") {\n      input = \"\";\n    } else {\n      const im = input.match(RDS5);\n\n      if (im) {\n        const s = im[0];\n        input = input.slice(s.length);\n        output.push(s);\n      } else {\n        throw new Error(\"Unexpected dot segment condition\");\n      }\n    }\n  }\n\n  return output.join(\"\");\n}\n;\nexport function serialize(components, options = {}) {\n  const protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n  const uriTokens = []; //find scheme handler\n\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()]; //perform scheme specific serialization\n\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n  if (components.host) {\n    //if host component is an IPv6 address\n    if (protocol.IPV6ADDRESS.test(components.host)) {//TODO: normalize IPv6 address as per RFC 5952\n    } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n      //convert IDN via punycode\n      try {\n        components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n      } catch (e) {\n        components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n      }\n    }\n  } //normalize encoding\n\n\n  _normalizeComponentEncoding(components, protocol);\n\n  if (options.reference !== \"suffix\" && components.scheme) {\n    uriTokens.push(components.scheme);\n    uriTokens.push(\":\");\n  }\n\n  const authority = _recomposeAuthority(components, options);\n\n  if (authority !== undefined) {\n    if (options.reference !== \"suffix\") {\n      uriTokens.push(\"//\");\n    }\n\n    uriTokens.push(authority);\n\n    if (components.path && components.path.charAt(0) !== \"/\") {\n      uriTokens.push(\"/\");\n    }\n  }\n\n  if (components.path !== undefined) {\n    let s = components.path;\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s);\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s);\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push(\"?\");\n    uriTokens.push(components.query);\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push(\"#\");\n    uriTokens.push(components.fragment);\n  }\n\n  return uriTokens.join(\"\"); //merge tokens into a string\n}\n;\nexport function resolveComponents(base, relative, options = {}, skipNormalization) {\n  const target = {};\n\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options); //normalize base components\n\n    relative = parse(serialize(relative, options), options); //normalize relative components\n  }\n\n  options = options || {};\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme; //target.authority = relative.authority;\n\n    target.userinfo = relative.userinfo;\n    target.host = relative.host;\n    target.port = relative.port;\n    target.path = removeDotSegments(relative.path || \"\");\n    target.query = relative.query;\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      //target.authority = relative.authority;\n      target.userinfo = relative.userinfo;\n      target.host = relative.host;\n      target.port = relative.port;\n      target.path = removeDotSegments(relative.path || \"\");\n      target.query = relative.query;\n    } else {\n      if (!relative.path) {\n        target.path = base.path;\n\n        if (relative.query !== undefined) {\n          target.query = relative.query;\n        } else {\n          target.query = base.query;\n        }\n      } else {\n        if (relative.path.charAt(0) === \"/\") {\n          target.path = removeDotSegments(relative.path);\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = \"/\" + relative.path;\n          } else if (!base.path) {\n            target.path = relative.path;\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n          }\n\n          target.path = removeDotSegments(target.path);\n        }\n\n        target.query = relative.query;\n      } //target.authority = base.authority;\n\n\n      target.userinfo = base.userinfo;\n      target.host = base.host;\n      target.port = base.port;\n    }\n\n    target.scheme = base.scheme;\n  }\n\n  target.fragment = relative.fragment;\n  return target;\n}\n;\nexport function resolve(baseURI, relativeURI, options) {\n  return serialize(resolveComponents(parse(baseURI, options), parse(relativeURI, options), options, true), options);\n}\n;\nexport function normalize(uri, options) {\n  if (typeof uri === \"string\") {\n    uri = serialize(parse(uri, options), options);\n  } else if (typeOf(uri) === \"object\") {\n    uri = parse(serialize(uri, options), options);\n  }\n\n  return uri;\n}\n;\nexport function equal(uriA, uriB, options) {\n  if (typeof uriA === \"string\") {\n    uriA = serialize(parse(uriA, options), options);\n  } else if (typeOf(uriA) === \"object\") {\n    uriA = serialize(uriA, options);\n  }\n\n  if (typeof uriB === \"string\") {\n    uriB = serialize(parse(uriB, options), options);\n  } else if (typeOf(uriB) === \"object\") {\n    uriB = serialize(uriB, options);\n  }\n\n  return uriA === uriB;\n}\n;\nexport function escapeComponent(str, options) {\n  return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n;\nexport function unescapeComponent(str, options) {\n  return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n;","map":null,"metadata":{},"sourceType":"module"}